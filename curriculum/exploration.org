#+TITLE:  Overtone Exploration
#+AUTHOR: Howard Abrams
#+EMAIL:  howard.abrams@gmail.com
#+DATE:   2015 Apr 24
#+TAGS:   clojure

The following /after-bridge/ extension will further expand your
knowledge of Clojure by investigating a Clojure extension for creating music.

#+BEGIN_QUOTE
    This is a story of Meg who attended a ClojureBridge workshop
    recently.  Meg has always been a bit of a music nerd, but wondered
    why DJs always used laptops on stage. Then she saw a live music
    coding video, and read that they use Clojure to create the
    music. Intrigued, she started to investigate Overtone.
#+END_QUOTE

[[http://overtone.github.io][Overtone]] is a way to generate sounds, instruments and music using
Clojure. While it is very advanced, it is pretty easy to get started,
and interesting to explore.

* Creating a Project with Overtone

  Like most Clojure projects, we begin by using =lein= to create a
  project to contain our programs:

  #+BEGIN_SRC sh :results verbatim
  lein new explore-overtone
  #+END_SRC

  Where you should see something like:

  #+BEGIN_EXAMPLE
  Generating a project called explore-overtone based on the 'default' template.
  The default template is intended for library projects, not applications.
  To see other templates (app, plugin, etc), try `lein help new`.
  #+END_EXAMPLE

  Once the skeleton program has been created, we need to edit the
  =project.clj= to add Overtone as a required library (dependency), so
  change the file from this:

  #+BEGIN_SRC clojure
  (defproject explore-overtone "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.6.0"]])
  #+END_SRC

  To this:

  #+BEGIN_SRC clojure
  (defproject explore-overtone "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.6.0"]
                   [overtone "0.9.1"]])
  #+END_SRC

  For the first part of our exploration of Overtone, we will use a
  REPL:

  #+BEGIN_SRC sh
    lein repl
  #+END_SRC

  The first time you run this, the =lein= program will take a while as
  it downloads our Overtone world.

  While all the libraries have been downloaded, they aren’t loaded into
  our REPL...not just yet. Bring them into our session, by typing the
  following into the REPL:

  #+BEGIN_SRC clojure
    (use 'overtone.live)
  #+END_SRC

  This command may split out some technical warnings, but we’ll ignore
  them for the moment, as we bask in welcome message:

  #+BEGIN_EXAMPLE
  SC_AudioDriver: sample rate = 44100.000000, driver's block size = 512
  Exception in World_OpenUDP: unable to bind udp socket

  --> Connecting to internal SuperCollider server...
  --> Connection established

      _____                 __
     / __  /_  _____  _____/ /_____  ____  ___
    / / / / | / / _ \/ ___/ __/ __ \/ __ \/ _ \
   / /_/ /| |/ /  __/ /  / /_/ /_/ / / / /  __/
   \____/ |___/\___/_/   \__/\____/_/ /_/\___/

     Collaborative Programmable Music. v0.9.1


  Cometh the hour, cometh your.name.here, the overtone hacker.

  nil
  user=>
  #+END_EXAMPLE

* Playing Piano Notes

  Overtone is quite modular, and even at this point, not everything is
  available to us. Let’s bring in a piano sound, by typing the
  following to use a piano function:

  #+BEGIN_SRC clojure
    (use 'overtone.inst.piano)
  #+END_SRC

  And let’s play a note, by calling the =piano= function:

  #+BEGIN_SRC clojure
    (piano)
  #+END_SRC

  Did you hear a piano note? Great! If not, we may have to diagnose
  our audio (you did turn up the volume, right?).[fn:1] You can hit the up
  arrow and the Return key in the REPL to quickly repeat this function.

  The =piano= function takes a note number:

  #+BEGIN_SRC clojure
    (piano 48)
  #+END_SRC

  The =48= is the number that corresponds to the note. Since musicians
  are used to notes, not numbers, Overtone includes a =note= function:

  #+BEGIN_SRC clojure
    (note :c3)
  #+END_SRC

  Executing this function returns =48=, so the value of =48=
  corresponds to a =C= note in the third octave. We could play our
  note this way:

  #+BEGIN_SRC clojure
    (piano (note :c3))
  #+END_SRC

  Let’s look at another function, =chord=. We can get more information
  about it by using the =doc= function. Type this into the REPL:

  #+BEGIN_SRC clojure
  (doc chord)
  #+END_SRC

  Which returns:

  #+BEGIN_EXAMPLE
  user=> (doc chord)
  -------------------------
  overtone.live/chord
  ([root chord-name] [root chord-name inversion])
    Returns a set of notes for the specified chord. The root must be in
    midi note format i.e. :C4.

    (chord :c4 :major)  ; c major           -> #{60 64 67}
    (chord :a4 :minor)  ; a minor           -> #{57 60 64}
    (chord :Bb4 :dim)   ; b flat diminished -> #{70 73 76}
  #+END_EXAMPLE

  Ah, so the following function call:

  #+BEGIN_SRC clojure
    (chord :c3 :major)
  #+END_SRC

  Returns:

  #+BEGIN_EXAMPLE
    (48 55 52)
  #+END_EXAMPLE

  This returns the three note numbers that correspond to the C major
  chord. While we *could* type all this one the same line to play a
  chord:

  #+BEGIN_SRC clojure
    (piano 48) (piano 55) (piano 52)
  #+END_SRC

  We are dealing with Clojure, and it has the ability to apply many
  values to the same function. Do you remember the =map= function? It
  takes a function (like =piano=) and a list of values for that function
  (like what is returned from =chord=). Type this:

  #+BEGIN_SRC clojure
    (map piano (chord :c3 :major))
  #+END_SRC

  Ha, ha! Should we make that simpler to type by creating a function?

  #+BEGIN_SRC clojure
    (defn piano-chord [root chord-name]
        (map piano (chord root chord-name)))
  #+END_SRC

  And now we can type the following if we aren’t feeling quite so happy
  for major chords:

  #+BEGIN_SRC clojure
   (piano-chord :c3 :minor)
  #+END_SRC

  However, the =inversion= parameter for the original =chord= function is
  optional, and our =piano-chord= should let us have this sort of
  /alternate/ behavior. When defining our =piano-chord= function, we can
  specify each /behavior/ based on the given parameters, like this:

  #+BEGIN_SRC clojure
    (defn piano-chord
      ([root chord-name]            (map piano (chord root chord-name)))
      ([root chord-name inversion]  (map piano (chord root chord-name inversion))))
  #+END_SRC

  Let’s parse this code. This function definition has two body
  entries, where the first element of each is a vector of the
  parameters. Based on the number of parameters, 2 or 3, either the
  first or second line is executed.

  In other words, if we call this function with two parameters (the
  =root= note, and the =chord-name=, the first line is called. If we
  specify three, the =root=, the =chord-name= /and/ the =inversion=,
  the second line is called.

  Let’s try it:

  #+BEGIN_SRC clojure
    (piano-chord :c3 :minor)     ;; moody chord
    (piano-chord :c3 :dim 4)     ;; seriously moody chord
  #+END_SRC

* Synthesizing Sound

  Let’s experiment with sound synthesis, as the [[https://github.com/overtone/overtone/wiki/Getting-Started#getting-started][Overtone Getting
  Started guide]] mentioned the =saw= function:

  #+BEGIN_SRC clojure
    (saw 440)
  #+END_SRC

  Not pleasant, and ZOMG-MAKE-IT-STOP! Quickly, type this:

  #+BEGIN_SRC clojure
    (stop)
  #+END_SRC

  Whew. We want to experiment, but...

  From now one, we will wrap our experimental functions in the =demo=
  function (which will stop them after a second):

  #+BEGIN_SRC clojure
    (demo (saw 440))
  #+END_SRC

  A [[http://en.wikipedia.org/wiki/Sawtooth_wave][sawtooth wave form]] is a bit /buzzy/, but Overtone has lots of
  base-level wave forms, let’s try making a more pleasing, but still,
  very computer-y, sound called a [[http://en.wikipedia.org/wiki/Sine_wave][sine wave form]]:

  #+BEGIN_SRC clojure
    (demo (sin-osc 440))
  #+END_SRC

  Every wave that can be generated, can be altered with other
  functions, like these:

  #+BEGIN_SRC clojure
    (demo (pan2 (sin-osc 440)))
  #+END_SRC

  Add =out=?

  #+BEGIN_SRC clojure
    (demo (out 0 (pan2 (sin-osc 440))))
  #+END_SRC

  Add =synth=?

  #+BEGIN_SRC clojure
  (demo (synth (out 0 (pan2 (sin-osc 440)))))
  #+END_SRC

  Use =defsynth= to create synthesizers and assign the player function
  a name, just like =defn=.  Note that synthesizer parameters must
  always have a default value, so we specify one if not given:

  #+BEGIN_SRC clojure
    (defsynth my-sin [freq 440]
      (out 0 (pan2 (sin-osc freq))))
  #+END_SRC

  So let’s play our sine wave at different frequencies:

  #+BEGIN_SRC clojure
    (my-sin)     ; uses the default
    (my-sin 220) ; an octave lower
    (my-sin 447)
  #+END_SRC

  Potential notes:

   - [[http://scottmuc.com/setting-up-overtone/][Nice, tutorial introduction]]
   - [[https://github.com/ctford/whelmed][Cloneable project with some music]]

* Footnotes

[fn:1] We should try to come up with a list of audio troubleshooting,
as if we can’t hear the music, this project won’t be much fun.
