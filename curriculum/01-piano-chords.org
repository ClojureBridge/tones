#+TITLE:  Overtone Exploration
#+AUTHOR: Howard Abrams
#+EMAIL:  howard.abrams@gmail.com
#+DATE:   2015 Apr 24
#+TAGS:   clojure

The following /after-bridge/ extension will further expand your
knowledge of Clojure by investigating a Clojure extension for creating music.

#+BEGIN_QUOTE
    This is a story of Meg who attended a ClojureBridge workshop
    recently.  Meg has always been a bit of a music nerd, but wondered
    why DJs always used laptops on stage. Then she saw a live music
    coding video, and read that they use Clojure to create the
    music. Intrigued, she started to investigate Overtone.
#+END_QUOTE

[[http://overtone.github.io][Overtone]] is a way to generate sounds, instruments and music using
Clojure. While it is very advanced, it is pretty easy to get started,
and interesting to explore.

* Creating a Project with Overtone

  Like most Clojure projects, we begin by using =lein= to create a
  project to contain our programs:

  #+BEGIN_SRC sh :results verbatim
    lein new explore-overtone
  #+END_SRC

  Where you should see something like:

  #+BEGIN_EXAMPLE
  Generating a project called explore-overtone based on the 'default' template.
  The default template is intended for library projects, not applications.
  To see other templates (app, plugin, etc), try `lein help new`.
  #+END_EXAMPLE

  Once the skeleton program has been created, we need to edit the
  =project.clj= to add Overtone as a required library (dependency), so
  change the file from this:

  #+BEGIN_SRC clojure
    (defproject explore-overtone "0.1.0-SNAPSHOT"
      :description "FIXME: write description"
      :url "http://example.com/FIXME"
      :license {:name "Eclipse Public License"
                :url "http://www.eclipse.org/legal/epl-v10.html"}
      :dependencies [[org.clojure/clojure "1.6.0"]])
  #+END_SRC

  To this:

  #+BEGIN_SRC clojure
    (defproject explore-overtone "0.1.0-SNAPSHOT"
      :description "FIXME: write description"
      :url "http://example.com/FIXME"
      :license {:name "Eclipse Public License"
                :url "http://www.eclipse.org/legal/epl-v10.html"}
      :dependencies [[org.clojure/clojure "1.6.0"]
                     [overtone "0.9.1"]])
  #+END_SRC

  For the first part of our exploration of Overtone, we will use a
  REPL:

  #+BEGIN_SRC sh
    lein repl
  #+END_SRC

  The first time you run this, the =lein= program will take a while as
  it downloads our Overtone world.

  While all the libraries have been downloaded, they aren’t loaded into
  our REPL...not just yet. Bring them into our session, by typing the
  following into the REPL:

  #+BEGIN_SRC clojure
    (use 'overtone.live)
  #+END_SRC

  This command may split out some technical warnings, but we’ll ignore
  them for the moment, as we bask in welcome message:

  #+BEGIN_EXAMPLE
  SC_AudioDriver: sample rate = 44100.000000, driver's block size = 512
  Exception in World_OpenUDP: unable to bind udp socket

  --> Connecting to internal SuperCollider server...
  --> Connection established

      _____                 __
     / __  /_  _____  _____/ /_____  ____  ___
    / / / / | / / _ \/ ___/ __/ __ \/ __ \/ _ \
   / /_/ /| |/ /  __/ /  / /_/ /_/ / / / /  __/
   \____/ |___/\___/_/   \__/\____/_/ /_/\___/

     Collaborative Programmable Music. v0.9.1


  Cometh the hour, cometh your.name.here, the overtone hacker.

  nil
  user=>
  #+END_EXAMPLE

* Playing Piano Notes

  Overtone is quite modular, and even at this point, not everything is
  available to us. Let’s bring in a piano sound, by typing the
  following to use a piano function:

  #+BEGIN_SRC clojure
    (use 'overtone.inst.piano)
  #+END_SRC

  And let’s play a note, by calling the =piano= function:

  #+BEGIN_SRC clojure
    (piano)
  #+END_SRC

  Did you hear a piano note? Great! If not, we may have to diagnose
  our audio (you did turn up the volume, right?).[fn:1] You can hit the up
  arrow and the Return key in the REPL to quickly repeat this function.

  The =piano= function takes a note number:

  #+BEGIN_SRC clojure
    (piano 48)
  #+END_SRC

  The =48= is the number that corresponds to the note. Since musicians
  are used to notes, not numbers, Overtone includes a =note= function:

  #+BEGIN_SRC clojure
    (note :c3)
  #+END_SRC

  Executing this function returns =48=, so the value of =48=
  corresponds to a =C= note in the third octave. We could play our
  note this way:

  #+BEGIN_SRC clojure
    (piano (note :c3))
  #+END_SRC

  Let’s look at another function, =chord=. We can get more information
  about it by using the =doc= function. Type this into the REPL:

  #+BEGIN_SRC clojure
  (doc chord)
  #+END_SRC

  Which returns:

  #+BEGIN_EXAMPLE
  user=> (doc chord)
  -------------------------
  overtone.live/chord
  ([root chord-name] [root chord-name inversion])
    Returns a set of notes for the specified chord. The root must be in
    midi note format i.e. :C4.

    (chord :c4 :major)  ; c major           -> #{60 64 67}
    (chord :a4 :minor)  ; a minor           -> #{57 60 64}
    (chord :Bb4 :dim)   ; b flat diminished -> #{70 73 76}
  #+END_EXAMPLE

  Ah, so the following function call:

  #+BEGIN_SRC clojure
    (chord :c3 :major)
  #+END_SRC

  Returns:

  #+BEGIN_EXAMPLE
    (48 55 52)
  #+END_EXAMPLE

  This returns the three note numbers that correspond to the C major
  chord. While we *could* type all this one the same line to play a
  chord:

  #+BEGIN_SRC clojure
    (piano 48) (piano 55) (piano 52)
  #+END_SRC

  Icky. We are dealing with Clojure, and it has the ability to apply many
  values to the same function. Do you remember the =map= function? It
  takes a function (like =piano=) and a list of values for that function
  (like what is returned from =chord=). Type this:

  #+BEGIN_SRC clojure
    (map piano (chord :c3 :major))
  #+END_SRC

  Ha, ha! Should we make that simpler to type by creating a function?

  #+BEGIN_SRC clojure
    (defn piano-chord [root chord-name]
        (map piano (chord root chord-name)))
  #+END_SRC

  And now we can type the following if we aren’t feeling quite so happy
  for major chords:

  #+BEGIN_SRC clojure
   (piano-chord :c3 :minor)
  #+END_SRC

  However, the =inversion= parameter for the original =chord= function is
  optional, and our =piano-chord= should let us have this sort of
  /alternate/ behavior. When defining our =piano-chord= function, we can
  specify each /behavior/ based on the given parameters, like this:

  #+BEGIN_SRC clojure
    (defn piano-chord
      ([root chord-name]            (map piano (chord root chord-name)))
      ([root chord-name inversion]  (map piano (chord root chord-name inversion))))
  #+END_SRC

  Let’s parse this code. This function definition has two body
  entries, where the first element of each is a vector of the
  parameters. Based on the number of parameters, 2 or 3, either the
  first or second line is executed.

  In other words, if we call this function with two parameters (the
  =root= note, and the =chord-name=, the first line is called. If we
  specify three, the =root=, the =chord-name= /and/ the =inversion=,
  the second line is called.

  Let’s try it:

  #+BEGIN_SRC clojure
    (piano-chord :c3 :minor)     ;; moody chord
    (piano-chord :c3 :dim 4)     ;; seriously moody chord
    (piano-chord :g3 :dom7)      ;; G7 major ... quite popular
  #+END_SRC

  Now we have to make a some progression, but let’s update our
  =piano-chord= function to take a single element that is a list
  containing our chord instructions, for instance:

  #+BEGIN_SRC clojure
    (piano-chord [:c3 :dim 4])
  #+END_SRC

  Why would we want to allow our function to take something that makes
  it even longer to type? Hang on, and let me show you how we do it,
  and then I’ll show you why it might be useful.

  #+BEGIN_SRC clojure
    (defn piano-chord
      ([all-in-one]                 (map piano (apply chord all-in-one)))
      ([root chord-name]            (map piano (chord root chord-name)))
      ([root chord-name inversion]  (map piano (chord root chord-name inversion))))
  #+END_SRC

  See the second line where we accept a single value, =all-in-one=? We
  call =map= like normal, but instead of calling =chord=, we call
  =(apply chord ...)=, and this converts our sequence, =all-in-one=,
  to a series of parameters to =chord=.

  Where something like this is useful, is if we wanted to make a
  /chord progression/.

like from /Yesterday/ (the
  1965 song by the Beattles): C major, B minor, E7, A minor, F major, G7, C major:

  #+BEGIN_SRC clojure
    (def yesterday [ [:c3 :major]
                     [:b4 :minor]
                     [:e4 :dom7]
                     [:a5 :minor]
                     [:f5 :major]
                     [:g6 :dom7]
                     [:c7 :major] ])

    (map play-and-wait yesterday)

    (defn play-and-wait [c]
        (piano-chord c)
        (Thread/sleep 1000))

    (play-and-wait

    (periodic 400 (partial piano-chord [:c3 :major]))
    (show-schedule)(examples)
  #+END_SRC

  While we will move on, if you are interested in playing realistic
  sounds, look at [[http://blog.josephwilk.net/clojure/creating-instruments-with-overtone.html][this essay and code]] for building up an
  ethereal-sounding flute solo, or check out the [[https://github.com/ctford/leipzig][Leipzig Library]] for
  making it easier to build this sort of compositions.
